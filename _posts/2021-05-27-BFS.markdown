---
layout: post
title: "BFS란?"
date: 2021-05-27 08:20:00 +0300
image: 02.png
tags: Algorithm
---
 
## 시작하는 말  

알고리즘을 공부할때 알게된 __너비 우선 탐색(BFS : Breadth-First Search)__ 을 복습하고자 한다.  

***

## 너비 우선 탐색(BFS, Breadth-First Search)  

루트 노드에서 시작해서 인접한 노드를 먼저 탐색하는 방법이다. 이는 __그래프 탐색__ (하나의 정점으로 시작하여 모든 정점을 한번씩 방문)에 속한다. BFS는 두 노드 사이의 __최단 경로__  및 __임의의 경로__ 를 찾을때 사용하며 자료 구조 __큐(Queue)__ 를 이용해 탐색을 한다.  

* 유사 알고리즘 : Prim, Dijkstra  


## 너비 우선 탐색(BFS) 예제  

방문 여부, 큐(Queue)를 활용하여 구현하였다.  

~~~python
def solution(v):
    result = [0, 0, 0]
    dx = [0, 1, 0, -1]
    dy = [1, 0, -1, 0]
    visited = [[0 for j in range(len(v)+2)] for i in range(len(v)+2)]
    q = []

    for i in range(len(v)):
        for j in range(len(v)):

            if visited[i][j] == 0:
                typeNum = v[i][j]
                q.append([i, j])

                while True:

                    if len(q) == 0:
                        result[typeNum] += 1
                        break
                    else:
                        qindex = q.pop(0)
                        qx = qindex[0]
                        qy = qindex[1]
                        for idx in range(4):
                            nextX = qx + dx[idx]
                            nextY = qy + dy[idx]
                            if nextX < len(v) and nextX >= 0 and nextY >= 0 and nextY < len(v):
                                if v[nextX][nextY] == typeNum and visited[nextX][nextY] == 0:
                                    q.append([nextX, nextY])
                                    visited[nextX][nextY] = 1
    # if visited[len(v)-1][len(v)-1] == 0:
    #    result[v[len(v)-1][len(v)-1]] += 1
    print(result)
~~~

~~~python
# 이자식은 BFS로 큐써서 같은 숫자 판별해서 더해서 어레이인덱스값에 더해주기
solution([[0, 0, 1, 1], [1, 1, 1, 1], [2, 2, 2, 1], [0, 0, 0, 2]])
~~~

***

#### 성장에 도움을 주신 개발자분  

[출처 : ](https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html) https://gmlwjd9405.github.io/2018/08/15/algorithm-bfs.html  

오늘도 감사합니다.  
