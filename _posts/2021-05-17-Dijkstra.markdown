---
layout: post
title: "Dijkstra 알고리즘"
date: 2021-05-18 08:35:00 +0300
image: routes.png
tags: Algorithm
---
 
## 시작하는 말  

드디어 블로그 이동을 마치고 다시 포스팅할 수 있게 되었습니다. 최근에 공부한 다익스트라 알고리즘을 포스팅하려 합니다. 그럼 틈틈히 작성 시작하겠습니다.

***

## 다익스트라(dijkstra) 알고리즘 이란?  

다익스트라 알고리즘은 최단경로를 탐색하는 알고리즘이다. 구현 방법으로 2차원 배열 또는 힙(Heap)을 이용하여 구현할 수 있으며 각각 O(N^2)와 O(ElogN) 시간복잡도를 가진다.  

다익스트라 알고리즘은 음수 가중치를 가진 그래프에서는 사용할 수 없는 단점이 있는데 이때에는 벨만-포드 알고리즘을 사용해야 합니다.  

***

## 원리  

1. 모든 가중치를 무한으로 설정한다.  
![dijkstra 1](/images/dijkstra1.PNG)  

2. 방문하지 않은 노드는 false, 방문한 곳은 true로 설정한다. __(하늘색 원안은 true)__  

3. 시작점에서 __연결된 노드__ 들의 가중치의 값을 변환한다.  
![dijkstra 2](/images/dijkstra2.PNG)  

4. 그 중 __가장 작은 값의 노드를 방문__ 한다.    
![dijkstra 3](/images/dijkstra3.PNG)  

5. __방문한 곳__ 에서부터 연결된 노드들의 가중치를 변환한다.  
![dijkstra 4](/images/dijkstra4.PNG)  

6. 그 가중치보다 다른 경로로 작은 값을 찾으면 해당 노드의 가중치를 변환하며 방문 처리를 하는 것이다.  
![dijkstra 5](/images/dijkstra5.PNG)  

***

## 2차원 배열로 구현한 예제 (JAVA)  

~~~ Java

	private static final int MY_LOCATION = 1; //시작점
	private static final int DESTINATION = 5; //목적지
	private static final int START = 0;		  //x
	private static final int END = 1;		  //y
	private static final int DISTANCE = 2;	  //가중치
	
~~~

	public static void main(String[] args) {
	   int N = 5;	//노드의 갯수
	   int[][] road = {{1,2,1}, {2,3,3}, {5,2,2}, {1,4,2}, {5,3,1}, {5,4,2}}; //연결 노드
	   int result = solution(N, road);

	   System.out.println(result);
	}

~~~ Java
	public static int solution(int n, int[][] road) {
		
		int maps[][] = new int[n+1][n+1];		//Map
		int distance[] = new int[n+1];			//노드들의 가중치
		boolean[] check = new boolean[n+1];		//방문여부
		
		//모든 가중치 가장 큰 값으로 초기 설정
		for(int i=1; i<n+1; i++) {
			distance[i] = Integer.MAX_VALUE;
		}
		
		//Map 그리기
		for(int i=0; i <road.length; i++) {
			maps[road[i][START]][road[i][END]] = road[i][DISTANCE];
			maps[road[i][END]][road[i][START]] = road[i][DISTANCE];
		}

		//시작점 셋팅
		distance[MY_LOCATION] = 0;
		check[MY_LOCATION] = true;
		
		//시작점에서 연결된 노드 연결
		for(int i=1;i<n+1;i++) {
			if(!check[i] && maps[MY_LOCATION][i] != 0) {//값 0 은 Null 의미
				distance[i] = maps[MY_LOCATION][i];
			}
		}
		
		//탐색 시작
		for(int t=0; t<n-1; t++) {
			int min_distance = Integer.MAX_VALUE;
			int min_index = -1;
			
			//최소값 탐색
			for(int i=1;i<n+1;i++) {
				if(!check[i] && distance[i]!=Integer.MAX_VALUE) {
					if(distance[i]<min_distance) {
						min_distance = distance[i];
						min_index = i;
					}
				}
			}
			check[min_index] = true;	//가장 최소값 방문
			
			for(int i=1; i<n+1; i++) {
				if(!check[i] && maps[min_index][i] != 0) {
					if(distance[i] > distance[min_index]+maps[min_index][i]) {
						distance[i] = distance[min_index]+maps[min_index][i];
					}
				}
			}
		}
        return distance[DESTINATION];
    }
~~~

***

#### 오늘 성장에 도움을 주신 개발자분  

[출처1](https://matice.tistory.com/56) https://matice.tistory.com/56  

[출처2](https://bumbums.tistory.com/4) https://bumbums.tistory.com/4  

[배경화면](https://cloud.google.com/maps-platform/routes/?hl=ko) https://cloud.google.com/maps-platform/routes/?hl=ko  

오늘도 감사합니다.  
